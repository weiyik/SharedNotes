# Methods and Functions in Scala

```scala
val a: Int = 1
```

## Getting Started

* Scala preferences
  * Immutable data and pure functions
  * Expressions over statements
* Keywords
  * `var`: mutable, evaluated right away
  * `val`: immutable, evaluated right away 
  * `lazy val`: immutable & not evaluated until firstly referenced
  * `def`: define a method, evaluated everytime method invoked
* Function vs Method
  * Functions are object, and methods are NOT
  * Methods are associated with class

```scala
val foo: Int => Int = (x: Int) => x * 2
def bar(x: Int): Int = x * 2
```

## Functions

```scala
val l = List(1,2,3,4,5)
l.filter((x: Int) => x > 3)
l.filter(x => x > 3) // target typing, the function literal's parameter type can be inferred, because it's applied on an Int list
l.filter(_ > 3) // placeholder

val foo: Int => Boolean = (_:Int) > 3
val add: (Double, Double) => Double = (_: Double) + (_:Double)
```

* Partial Function
  * extends Function1
  * A partial function of type `PartialFunction[A, B]` is a unary function where the domain does not necessarily include all values of type `A`. The function `isDefinedAt` allows to test dynamically if a value is in the domain of the function.

```scala
@ val par = new PartialFunction[Int, Int] {
>   def apply(x: Int): Int = 64 / x
>   def isDefinedAt(x: Int): Boolean = x != 0
> }
par: AnyRef with PartialFunction[Int, Int] = <function1>

@ par(8)
res51: Int = 8

@ par(0)    // still throw error
java.lang.ArithmeticException: / by zero
  ammonite.$sess.cmd50$$anon$1.apply$mcII$sp(cmd50.sc:2)
  ammonite.$sess.cmd52$.<clinit>(cmd52.sc:1)


@ if(par.isDefinedAt(0)) par(0)
res53: AnyVal = ()

@ if(par.isDefinedAt(2)) par(2)
res54: AnyVal = 32
```

```scala
// partial function with pattern matching
@ val par: PartialFunction[Int, Int] = { case x: Int if x != 0 => 64 / x }
par: PartialFunction[Int, Int] = <function1>

@ par.isDefinedAt(0)
res56: Boolean = false
```

```scala
// map vs collect
@ List(8, 4, 2, 1, 0) map par
scala.MatchError: 0 (of class java.lang.Integer)
  scala.PartialFunction$$anon$1.apply(PartialFunction.scala:369)
  ...

@ List(8, 4, 2, 1, 0) collect par
res58: List[Int] = List(8, 16, 32, 64)
```

```scala
@ val parFor0: PartialFunction[Int, Int] = { case x: Int if x == 0 => Int.MaxValue }
parFor0: PartialFunction[Int, Int] = <function1>

// combining partial functions
@ val div = par orElse parFor0
div: PartialFunction[Int, Int] = <function1>

@ div(0)
res66: Int = 2147483647

@ div(16)
res68: Int = 4
```

* High Order Functions
  * accept function as parameter, or return a function

```scala
@ val genFunc = (base: Int) => {
>   (x: Int) => x / base
> }
genFunc: Int => Int => Int = ammonite.$sess.cmd0$$$Lambda$1418/0x00000008011c7890@3ad394e6

@ genFunc(2)(10)
res2: Int = 5
```

```scala
@ var b = 6
b: Int = 6

// relies on outside variable
@ val genFuncB = () => {
>   (x: Int) => x / b
> }
genFuncB: () => Int => Int = ammonite.$sess.cmd9$$$Lambda$1856/0x000000080124a770@350ff014

@ val foo = genFuncB()
foo: Int => Int = ammonite.$sess.cmd9$$$Lambda$1869/0x0000000800d60c00@6f240187

@ foo(30)
res13: Int = 5

@ b = 10

@ foo(30)
res15: Int = 3
```

## Methods

* input arguments are `val` types
* **procedure**: method has no `=` sign, and return `Unit`
  * `def printA(a: Int) { println(a) }`
* Currying
  * multiple argument list

```scala
@ def add(a:Int)(b:Int) = a + b
defined function add

@ add(1)(2)
res21: Int = 3

@ val add1 = add(1) _
add1: Int => Int = ammonite.$sess.cmd22$$$Lambda$1949/0x0000000801281720@391b03b

@ add1(12)
res23: Int = 13
```

* Generic method
  * `def show[A](a: A)(b: A) = s"$a, $b"`
* Call by name

```scala
def add(a: => Int, b: Int) = { println("starting add"); a + b }
def a = { println("init a"); 1 }
println(add(a, 2))  
----
starting add
init a
3
```
