# Scala Collections

* Sequences
* Sets
* Maps

---

* Mutable / Immutable
* Concurrent
* Trie
  
## List ([2.12](https://www.scala-lang.org/api/2.12.0/scala/collection/immutable/List.html))

* immutable
* linked list
  * optimal for last-in-first-out (LIFO). If you need random access or FIFO, consider other collections.
  * `O(1)` to prepend and head/tail access. Most other operations are `O(n)`.

```scala
List(1, 2, 3) // res0: List[Int] = List(1, 2, 3)
List("a", "b") // res1: List[String] = List(a, b)
1 :: 2 :: Nil // res0: List[Int] = List(1, 2)
```

* `Nil` is empty List, `Nil extends List`
* `::` (cons) is a def on `List`, prepend a value to list

### How to traverse a List

1. `foreach` method
2. `iterator` and `do-while`
3. generator based `for` loop
4. `foreach` implemented by `Iterator`

```scala
val nums = List(1, 2, 3, 4, 5)

nums.foreach(print(_))

val iterator = nums.iterator
while(iterator.hasNext)
  print(iterator.next())

for(element <- nums.iterator)
  print(element)

for(element <- nums)
  print(element)
// under the hood, the for loop is converted to foreach implemented by Iterator Trait
nums.foreach(print(_))
```

* `Traversable[+A]` trait has `def foreach[U](f: Elem => U): Unit`, and `Seq`, `Set`, `Map` extend it. It's deprecated since 2.13
* `Iterable[+A]` defines `foreach` method

### Find element in List

* Pattern matching
  * 14 Types: <https://data-flair.training/blogs/scala-pattern-matching/>

```scala
value match {
    case pattern guard => expression
    case ...
    case _ => default
}
```

```scala
val letters = List("A", "B", "C", "D")
// extractor pattern
letters match {
  case List("A", _, _) => println("found A")
  case List(_, "B", x, _*) if x == "C" => println("C is after B!")
  case List(_, "B", _*) => println("found B")
  case _ => println("match fail")
}
---
C is after B!
```

* Leverage the recursive nature of List
  * may cause stack overflow error
  
```scala
def sum(l: List[Int]): Int = {
  if (l.isEmpty) 0
  else l.head + sum(l.tail)
}

def find[A](target: A, l: List[A]): Option[A] = {
  if (l.isEmpty) None
  else if (l.head == target) Some(l.head)
  else find(target, l.tail)
}
```

* Pattern matching on Nil and ::(Cons)

```scala
def sum(l: List[Int]): Int = {
  l match {
    case head :: tail => head + sum(tail)
    case Nil => 0
  }
}
// But above method may create too many stack frames. To avoid this, use @tailrec
@tailrec
def sum(l: List[Int], accumulator: Int): Int = {
  l match {
    case Nil => accumulator
    case head :: tail => sum(tail, head + accumulator)
  }
}
```


## Tuple

## Monads
